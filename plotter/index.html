<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript">
      // TODO
      // Grid dashed lines
      // Axis tick rounding errors
      // Axis label rounding
      function arrayMin(x) {
        var result = x[0];
        for (var i = 1; i < x.length; i++) {
          result = Math.min(result, x[i]);
        }
        return result;
      }
      function arrayMax(x) {
        var result = x[0];
        for (var i = 1; i < x.length; i++) {
          result = Math.max(result, x[i]);
        }
        return result;
      }
      function areObjectsEqual(a, b) {
        if (typeof a != typeof b) {
          console.log('Types unequal: ' + typeof a + ', ' + typeof b);
          return false;
        }
        if (typeof a == 'object') {
          for (i in a) {
            if (!areObjectsEqual(a[i], b[i])) {
              //console.log('Unequal property ' + i);
              return false;
            }
          }
          return true;
        }
        return a == b;
      }
      function createTextSpan(text) {
        var span = document.createElement('span');
        span.innerText = text;
        return span;
      }
      function createDiv(className) {
        var div = document.createElement('div');
        div.className = className;
        return div;
      }
      function getMultiple(x) {
        if (x < 1 || x > 10) {
          throw new Error('Out of range: ' + x);
        }
        // Purely empirical
        if (x > 6) {
          return 2;
        }
        if (x > 4) {
          return 1;
        }
        if (x > 2) {
          return 0.5;
        }
        return 0.2;
      }
      function roundToMultiple(x, multiple, roundUp) {
        var isPositive = x > 0;
        fraction = Math.abs(x) / multiple;
        var rounded;
        if (roundUp == isPositive) {
          rounded = Math.ceil(fraction);
        } else {
          rounded = Math.floor(fraction);
        }
        //console.log('x: ' + x + ', multiple: ' + multiple + ', roundUp: ' + roundUp + ', fraction: ' + fraction + ', rounded: ' + rounded);
        var result = (isPositive ? 1 : -1) * multiple * rounded;
        //console.log('result: ' + result);
        return result;
      }
      function roundTowardsZero(x, multiple) {
        var sign = x < 0 ? -1 : 1;
        return sign * multiple * Math.ceil(Math.abs(x) / multiple);
      }
      function calculateAxisRange(dataRange, forceZero) {
        if (forceZero) {
          dataRange.expand(0);
        }
        var order = calculateOrder(dataRange.range());
        //console.log('order: ' + order);
        var value = dataRange.range() / order;
        //console.log('value: ' + value);
        var baseMultiple = getMultiple(value);
        //console.log('baseMultiple: ' + baseMultiple);
        var multiple = baseMultiple * order
        //console.log('multiple: ' + multiple);
        return new Range(roundToMultiple(dataRange.min(), multiple, false),
                         roundToMultiple(dataRange.max(), multiple, true));
      }
      function calculateOrder(x) {
        return Math.pow(10, Math.floor(Math.log(x) / Math.LN10));
      }
      function calculateAxisTick(axisRange) {
        var order = calculateOrder(axisRange);
        //console.log('order: ' + order);
        var value = axisRange / order;
        //console.log('value: ' + value);
        var interval;
        if (value > 5) {
          interval = 1;
        } else if (value > 2) {
          interval = 0.5;
        } else if (value > 1) {
          interval = 0.2;
        } else {
          interval = 0.1;
        }
        return interval * order;
      }

      /////////////////////////////////////////////////////////////////////////
      function test() {
        var tester = new Tester(document.getElementById('testResults'));
        // Basic
        tester.test('calculateAxisRange(new Range(0, 10))', '{min_: 0, max_: 10}');
        tester.test('calculateAxisRange(new Range(0, 11))', '{min_: 0, max_: 12}');
        tester.test('calculateAxisRange(new Range(0, 12))', '{min_: 0, max_: 12}');
        tester.test('calculateAxisRange(new Range(0, 13))', '{min_: 0, max_: 14}');
        tester.test('calculateAxisRange(new Range(0, 14))', '{min_: 0, max_: 14}');
        tester.test('calculateAxisRange(new Range(0, 15))', '{min_: 0, max_: 16}');
        tester.test('calculateAxisRange(new Range(0, 16))', '{min_: 0, max_: 16}');
        tester.test('calculateAxisRange(new Range(0, 17))', '{min_: 0, max_: 18}');
        tester.test('calculateAxisRange(new Range(0, 18))', '{min_: 0, max_: 18}');
        tester.test('calculateAxisRange(new Range(0, 19))', '{min_: 0, max_: 20}');
        tester.test('calculateAxisRange(new Range(0, 20))', '{min_: 0, max_: 20}');
        tester.test('calculateAxisRange(new Range(0, 21))', '{min_: 0, max_: 25}');
        tester.test('calculateAxisRange(new Range(0, 25))', '{min_: 0, max_: 25}');
        tester.test('calculateAxisRange(new Range(0, 26))', '{min_: 0, max_: 30}');
        tester.test('calculateAxisRange(new Range(0, 30))', '{min_: 0, max_: 30}');
        tester.test('calculateAxisRange(new Range(0, 31))', '{min_: 0, max_: 35}');
        tester.test('calculateAxisRange(new Range(0, 35))', '{min_: 0, max_: 35}');
        tester.test('calculateAxisRange(new Range(0, 36))', '{min_: 0, max_: 40}');
        tester.test('calculateAxisRange(new Range(0, 40))', '{min_: 0, max_: 40}');
        tester.test('calculateAxisRange(new Range(0, 41))', '{min_: 0, max_: 50}');
        tester.test('calculateAxisRange(new Range(0, 50))', '{min_: 0, max_: 50}');
        tester.test('calculateAxisRange(new Range(0, 51))', '{min_: 0, max_: 60}');
        tester.test('calculateAxisRange(new Range(0, 60))', '{min_: 0, max_: 60}');
        tester.test('calculateAxisRange(new Range(0, 61))', '{min_: 0, max_: 80}');
        tester.test('calculateAxisRange(new Range(0, 80))', '{min_: 0, max_: 80}');
        tester.test('calculateAxisRange(new Range(0, 81))', '{min_: 0, max_: 100}');
        tester.test('calculateAxisRange(new Range(0, 100))', '{min_: 0, max_: 100}');
        // Different orders of magnitude
        tester.test('calculateAxisRange(new Range(0, 0.01))', '{min_: 0, max_: 0.01}');
        tester.test('calculateAxisRange(new Range(0, 100))', '{min_: 0, max_: 100}');
        // Partial ranges
        tester.test('calculateAxisRange(new Range(1, 3))', '{min_: 1, max_: 3}');
        tester.test('calculateAxisRange(new Range(1, 9))', '{min_: 0, max_: 10}');
        // Negative
        tester.test('calculateAxisRange(new Range(-10, 0))', '{min_: -10, max_: 0}');
        tester.test('calculateAxisRange(new Range(-10, 10))', '{min_: -10, max_: 10}');
        tester.test('calculateAxisRange(new Range(-10, -1))', '{min_: -10, max_: 0}');
        tester.test('calculateAxisRange(new Range(-3, 3))', '{min_: -3, max_: 3}');
        tester.test('calculateAxisRange(new Range(-5, 5))', '{min_: -6, max_: 6}');
        // Tricky
        tester.test('calculateAxisRange(new Range(-15, 35))', '{min_: -20, max_: 40}');
        // Intervals
        tester.test('calculateAxisTick(5)', '0.5');
        tester.test('calculateAxisTick(10)', '1');
        tester.test('calculateAxisTick(12)', '2');
      }

      function test2() {
        // Global for use from inspector
        plot = new Plot(500, 500);
        document.body.appendChild(plot.canvas());

        //plot.plot([5, 11], [1, 4], 'red', '.');
        //plot.setHoldOn(true);
        //plot.plot([3.2, 5, 9.9], [-1, 200, 201], 'blue', 'o');
        //plot.setHoldOn(true);

        // Workout data: day vs joules
        plot.plot([1, 2, 3, 4, 5, 6, 7], [2100, 2200, 2300, 2480, 2535, 2610, 2735], 'green', '.');
        plot.forceAxisZero(false, true);
        plot.setGridOn(true);

        //plot.forceAxisZero(false, true);
        //plot.setAxisRanges(new Range(0, 10), new Range(1500, 4000));

        //plot.setHoldOn(true);
        //plot.plot([1, 2, 3, 4, 5], [3100, 3200, 3300, 3480, 3535], 'cyan', 'o');
        //plot.setAxisRanges();

        //plot.plot([-0.001, 4.2], [-110, -89]);
      }

      /////////////////////////////////////////////////////////////////////////
      function Tester(resultsDiv) {
        this.resultsDiv_ = resultsDiv;
        this.resultsDiv_.innerHTML = '';
        this.resultsDiv_.appendChild(createTextSpan('Test results'));
      }
      Tester.prototype.test = function(expressionString, resultString) {
        var actual = eval(expressionString);
        // Need ro make sure the eval has a return value?!
        var expected = eval('foo = ' + resultString);
        var div = createDiv('test pass');
        div.appendChild(createTextSpan(expressionString));
        if (!areObjectsEqual(expected, actual)) {
          div.appendChild(createTextSpan(' : Expected ' + resultString));
          div.className = 'test fail';
          // TODO: Print actual result.
        } else {
          div.appendChild(createTextSpan(' : ' + resultString));
        }
        this.resultsDiv_.appendChild(div);
      }

      /////////////////////////////////////////////////////////////////////////
      // TODO: Could merge this with Rect?
      function Range(min, max) {
        if (min == undefined) {
          this.min_ = Infinity;
        } else {
          this.min_ = min;
        }
        if (max == undefined) {
          this.max_ = - Infinity;
        } else {
          this.max_ = max;
        }
      }
      Range.prototype.min = function() {
        return this.min_;
      }
      Range.prototype.max = function() {
        return this.max_;
      }
      Range.prototype.range = function() {
        return this.max_ - this.min_;
      }
      Range.prototype.expand = function(x) {
        this.min_ = Math.min(this.min_, x);
        this.max_ = Math.max(this.max_, x);
      }
      // Gets the fraction through the range that value x is.
      Range.prototype.fraction = function(x) {
        return (x - this.min_) / this.range();
      }
      Range.prototype.print = function() {
        return '{min: ' + this.min_ + '; max: ' + this.max_ + '}';
      }

      /////////////////////////////////////////////////////////////////////////
      // TODO: x and y are decoupled, so could split up and merge with Range?
      function Rect(x, y, width, height) {
        this.x_ = x;
        this.y_ = y;
        this.width_ = width;
        this.height_ = height;
      }
      Rect.prototype.x = function() {
        return this.x_;
      }
      Rect.prototype.y = function() {
        return this.y_;
      }
      Rect.prototype.width = function() {
        return this.width_;
      }
      Rect.prototype.height = function() {
        return this.height_;
      }
      Rect.prototype.xMax = function() {
        return this.xInterpolate(1);
      }
      Rect.prototype.yMax = function() {
        return this.yInterpolate(1);
      }
      Rect.prototype.xInterpolate = function(x) {
        return this.x_ + this.width_ * x;
      }
      Rect.prototype.yInterpolate = function(y) {
        return this.y_ + this.height_ * y;
      }
      Rect.prototype.print = function() {
        return '{x: ' + this.x_ + '; y: ' + this.y_ + '; width: ' + this.width_ + '; height: ' + this.height_ + '}';
      }

      /////////////////////////////////////////////////////////////////////////
      function Axes(xRange, xTick, yRange, yTick) {
	// We allow for ticks that don't align precisely with the axis bounds,
	// even though the Plotter ensures this by default.
        this.xRange_ = xRange;
        this.yRange_ = yRange;
        this.xTick_ = xTick;
        this.yTick_ = yTick;
        this.gridOn_ = false;
      }
      Axes.prototype.setGridOn = function(gridOn) {
        this.gridOn_ = gridOn;
      }
      // TODO: Allow force of equal scales?
      Axes.prototype.draw = function(context, rect) {
        console.log('Axes.draw()');
        context.strokeStyle = 'black';
        context.strokeRect(rect.x(), rect.y(), rect.width(), rect.height());
        var tickLength = 5;

        var xTickFirst = roundToMultiple(this.xRange_.min(), this.xTick_, true);
        context.beginPath();
        for (var x = xTickFirst; x <= this.xRange_.max(); x += this.xTick_) {
          var xCoord = rect.xInterpolate(this.xRange_.fraction(x));
          context.moveTo(xCoord, rect.yMax() + tickLength); 
          context.lineTo(xCoord, rect.yMax());
          context.fillText(x, xCoord, rect.yMax() + 3 * tickLength);
          if (this.gridOn_) {
            // TODO: Make dashed
            context.lineTo(xCoord, rect.y());
          }
        }
        var yTickFirst = roundToMultiple(this.yRange_.min(), this.yTick_, true);
        for (var y = yTickFirst; y <= this.yRange_.max(); y += this.yTick_) {
          var yCoord = rect.yInterpolate(1 - this.yRange_.fraction(y));
          context.moveTo(rect.x() - tickLength, yCoord); 
          context.lineTo(rect.x(), yCoord);
          if (this.gridOn_) {
            // TODO: Make dashed
            context.lineTo(rect.xMax(), yCoord);
          }
          context.fillText(y, rect.x() - 5 * tickLength, yCoord);
        }
        context.stroke();
      }

      /////////////////////////////////////////////////////////////////////////
      function Plot(width, height) {
        this.width_ = width;
        this.height_ = height;
        this.forceXAxisZero_ = false;
        this.forceYAxisZero_ = false;
        this.axisRangesForced = false;
        this.holdOn_ = false;
        this.gridOn_ = false;
        this.clearData();
        this.createCanvas();
        var plotSize = 0.8;
        this.plotRect_ = new Rect(width * (1 - plotSize) / 2, height * (1 - plotSize) / 2, width * plotSize, height * plotSize);
      }
      Plot.prototype.canvas = function() {
        return this.canvas_;
      }
      Plot.prototype.setHoldOn = function(holdOn) {
        this.holdOn_ = holdOn;
      }
      Plot.prototype.setGridOn = function(gridOn) {
        this.gridOn_ = gridOn;
        if (this.axes_) {
          this.axes_.setGridOn(this.gridOn_);
        }
        this.redraw();
      }
      Plot.prototype.clearData = function() {
        this.dataSeries_ = [];
        this.xRange_ = new Range();
        this.yRange_ = new Range();
      }
      Plot.prototype.createCanvas = function() {
        this.canvas_ = document.createElement('canvas');
        this.canvas_.width = this.width_;
        this.canvas_.height = this.height_;
        this.context_ = this.canvas_.getContext('2d');
      }
      Plot.prototype.clearCanvas = function() {
        this.context_.clearRect(0, 0, this.width_, this.height_);
      }
      Plot.prototype.plot = function(x, y, color, marker, drawLine) {
        console.log('Plot.plot()');
        if (x.length != y.length) {
          throw new Error('Can not plot data series of lengths ' + x.length + ' and ' + y.length);
        }
        if (drawLine == undefined) {
          drawLine = true;
        }
        if (!this.holdOn_) {
          this.clearData();
        }
        this.updateData(x, y, color, marker, drawLine);
        if (!this.axisRangesForced_) {
          this.calculateDefaultAxisRanges();
        }
        this.redraw();
      }
      Plot.prototype.redraw = function() {
        console.log('Plot.redraw()');
        if (this.dataSeries_.length == 0) {
          return;
        }
        this.clearCanvas();
        this.axes_.draw(this.context_, this.plotRect_);
        for (var i = 0; i < this.dataSeries_.length; i++ ) {
          var data = this.dataSeries_[i];
          this.context_.strokeStyle = data.color == undefined ? 'black' : data.color;
          // Line
          if (data.drawLine) {
            this.context_.beginPath();
            this.context_.moveTo(this.xCoord(data.x[0]), this.yCoord(data.y[0]));
            for (var j = 0; j < data.x.length; j++ ) {
              this.context_.lineTo(this.xCoord(data.x[j]), this.yCoord(data.y[j]));
            }
            this.context_.stroke();
          }
          // Markers - need separate loop as they count as part of the stroke.
          if (data.marker != undefined) {
            var radius = 3;
            for (var j = 0; j < data.x.length; j++ ) {
              this.context_.beginPath();
              if (data.marker == '.') {
                this.context_.arc(this.xCoord(data.x[j]), this.yCoord(data.y[j]), 1, 0, 2 * Math.PI);
                // TODO: Fill?
                this.context_.stroke();
              } else if (data.marker == 'o') {
                this.context_.arc(this.xCoord(data.x[j]), this.yCoord(data.y[j]), radius, 0, 2 * Math.PI);
                this.context_.stroke();
              } else if (data.marker == 's') {
                this.context_.strokeRect(this.xCoord(data.x[j]) - radius, this.yCoord(data.y[j]) - radius, 2 * radius, 2 * radius);
              }
            }
          }
        }
      }
      Plot.prototype.updateData = function(x, y, color, marker, drawLine) {
        console.log('Plot.updateData()');
        this.dataSeries_.push({x: x, y: y, color: color, marker: marker, drawLine: drawLine});
        this.xRange_.expand(arrayMin(x));
        this.xRange_.expand(arrayMax(x));
        this.yRange_.expand(arrayMin(y));
        this.yRange_.expand(arrayMax(y));
        console.log('xRange: ' + this.xRange_.print());
        console.log('yRange: ' + this.yRange_.print());
      }
      Plot.prototype.calculateDefaultAxisRanges = function() {
        console.log('Plot.calculateDefaultAxisRanges()');
        // This will be called again when some data is added in plot().
        if (this.dataSeries_.length == 0) {
          return;
        }
        var xAxisRange = calculateAxisRange(this.xRange_, this.forceXAxisZero_);
        var yAxisRange = calculateAxisRange(this.yRange_, this.forceYAxisZero_);
        console.log('xAxisRange: ' + xAxisRange.print());
        console.log('yAxisRange: ' + yAxisRange.print());
        var xAxisTick = calculateAxisTick(xAxisRange.range());
        var yAxisTick = calculateAxisTick(yAxisRange.range());
        console.log('xAxisTick: ' + xAxisTick);
        console.log('yAxisTick: ' + yAxisTick);
        this.axes_ = new Axes(xAxisRange, xAxisTick, yAxisRange, yAxisTick);
        this.axes_.setGridOn(this.gridOn_);
      }
      // TODO: Better to introduce Point type and do x and y together?
      Plot.prototype.xCoord = function(x) {
        return this.plotRect_.xInterpolate(this.axes_.xRange_.fraction(x));
      }
      Plot.prototype.yCoord = function(y) {
        return this.plotRect_.yInterpolate(1 - this.axes_.yRange_.fraction(y));
      }
      // When in auto-axis mode, forces the axis range to include zero. Use 1
      // arg to control  both axes, 2 args to control x and y separately.
      Plot.prototype.forceAxisZero = function(arg1, arg2) {
        this.forceXAxisZero_ = arg1;
        if (arg2 == undefined) {
          this.forceYAxisZero_ = arg1;
        } else {
          this.forceYAxisZero_ = arg2;
        }
	// If the axes are forced, don't update or redraw them, but leave the
	// flags above set for when forcing is disabled.
        if (!this.axisRangesForced_) {
          this.calculateDefaultAxisRanges();
          this.redraw();
        }
      }
      // Forces the axis ranges. These are retained for future plot commands.
      // Call with no params to reset to auto mode.
      Plot.prototype.setAxisRanges = function(xAxisRange, yAxisRange) {
        if (xAxisRange == undefined && yAxisRange == undefined) {
          this.axisRangesForced_ = false;
          this.calculateDefaultAxisRanges();
        } else {
          this.axisRangesForced_ = true;
          var xAxisTick = calculateAxisTick(xAxisRange.range());
          var yAxisTick = calculateAxisTick(yAxisRange.range());
          this.axes_ = new Axes(xAxisRange, xAxisTick, yAxisRange, yAxisTick);
          this.axes_.setGridOn(this.gridOn_);
        }
        this.redraw();
      }
    </script>
    <style type="text/css">
      canvas {
        border: 1px solid black;
      }
      div.test {
        margin: 1px;
        border: 1px solid black;
        font-size: small;
      }
      div.pass {
        background-color: green;
      }
      div.fail {
        background-color: red;
      }
    </style>
  </head>
  <body onload="test2();">
    <pre id="testResults"></pre>
  <body>
</html>
